<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚¸ãƒ£ãƒ³ãƒ—æœ¬èªŒé–¢é€£Xãƒã‚¹ãƒˆæ•°</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“Š ã‚¸ãƒ£ãƒ³ãƒ—æœ¬èªŒé–¢é€£Xãƒã‚¹ãƒˆæ•°</h1>
        </div>

        <div class="datetime-setting">
            <h3>ğŸ“… åŸºæº–å·æ•°è¨­å®š</h3>
            <div class="datetime-input">
                <span class="datetime-label">åŸºæº–å·æ•°:</span>
                <select id="referenceIssueNumber" onchange="updateReferenceIssueNumber()">
                </select>
                <span id="selectedIssueDate" style="margin-left: 10px; color: #666; font-size: 0.9em;"></span>
            </div>
        </div>

        <div class="query-editor" id="trendEditor">
            <h2>ğŸ”¥ ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰è¨­å®š</h2>
            <p style="color: #666; margin-bottom: 10px; font-size: 0.9em;">ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰ã¯å„ä½œå“ã®ã‚¯ã‚¨ãƒªã«è‡ªå‹•è¿½åŠ ã•ã‚Œã¾ã™</p>
            <div class="trend-list" id="trendList">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #f8f9fa;">
                            <th style="padding: 10px; text-align: left; border-bottom: 2px solid #667eea;">ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰</th>
                            <th style="padding: 10px; text-align: left; border-bottom: 2px solid #667eea;">ä½œå“å</th>
                            <th style="padding: 10px; text-align: left; border-bottom: 2px solid #667eea;">æœ€é«˜é †ä½</th>
                            <th style="padding: 10px; text-align: center; border-bottom: 2px solid #667eea; width: 100px;">æ“ä½œ</th>
                        </tr>
                    </thead>
                    <tbody id="trendTableBody">
                        <!-- ãƒˆãƒ¬ãƒ³ãƒ‰ãŒå‹•çš„ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
                    </tbody>
                </table>
            </div>
        </div>

        <div class="query-editor" id="queryEditor">
            <h2>ğŸ” æ¤œç´¢ã‚¯ã‚¨ãƒªè¨­å®š</h2>
            <div class="select-controls">
                <button class="btn btn-small" onclick="selectAllQueries()">âœ“ å…¨é¸æŠ</button>
                <button class="btn btn-small" onclick="deselectAllQueries()">âœ— å…¨è§£é™¤</button>
                <span class="select-count" id="selectCount">0/0 ä½œå“é¸æŠä¸­</span>
            </div>
            <div class="query-list" id="queryList"></div>
            <div class="editor-actions">
                <button class="btn btn-secondary" onclick="resetQueries()">ğŸ”„ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™</button>
            </div>
        </div>

        <div class="controls">
            <button class="btn" id="startBtn" onclick="startAnalysis()">
                ğŸš€ è§£æé–‹å§‹
            </button>
            <button class="btn btn-secondary" id="saveBtn" onclick="saveToCSV()" style="display: none;">
                ğŸ’¾ ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
            </button>
        </div>

        <div class="progress-container" id="progressContainer">
            <h2>è§£æä¸­...</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
            <div class="progress-text" id="progressText">æº–å‚™ä¸­...</div>
        </div>

        <div id="reportContainer" class="report-container">
            <div class="report-header">
                <h2 class="report-title">ä»Šé€±ã®ã‚¸ãƒ£ãƒ³ãƒ—æœ¬èªŒé–¢é€£Xãƒ‡ãƒ¼ã‚¿</h2>
                <p class="report-subtitle">ãƒ„ã‚¤ãƒ¼ãƒˆæ•°ï¼šYahooãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¤œç´¢ã‚’å…ƒã«é›†è¨ˆ</p>
                <p class="report-subtitle">ãƒˆãƒ¬ãƒ³ãƒ‰ï¼šTwitterdã‚’å…ƒã«é›†è¨ˆ</p>
            </div>
            <div id="rankingGrid" class="ranking-grid"></div>
        </div>

        <div id="summaryTable" style="display: none;" class="summary-table">
            <h2 style="margin-bottom: 20px; color: #667eea;">ğŸ“ˆ ã‚µãƒãƒªãƒ¼</h2>
            <table id="summaryTableContent"></table>
        </div>

        <div class="results-container" id="resultsContainer"></div>
    </div>

    <script>
        let progressInterval = null;
        let currentQueries = [];
        let originalQueries = {}; // å…ƒã®ã‚¯ã‚¨ãƒªã‚’ä¿æŒ {ä½œå“å: [ã‚¯ã‚¨ãƒªè¦ç´ ã®ãƒªã‚¹ãƒˆ]}
        let currentReferenceIssueNumber = 1;
        let issueDateMapping = {}; // å·æ•°ã¨æ—¥ä»˜ã®ãƒãƒƒãƒ”ãƒ³ã‚°
        let trendWords = []; // ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰ã®ãƒªã‚¹ãƒˆ [{word: "", workName: "", rank: ""}]
        let querySelections = {}; // å„ä½œå“ã®é¸æŠçŠ¶æ…‹ã‚’ä¿æŒ
        let currentResults = null; // çµæœãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒ
        let currentReportTab = 'total'; // ç¾åœ¨ã®ãƒ¬ãƒãƒ¼ãƒˆã‚¿ãƒ–

        function getImageUrl(queryName) {
            return `/static/images/${queryName}.jpg`;
        }

        function updateReferenceIssueNumber() {
            const issueSelect = document.getElementById('referenceIssueNumber');
            currentReferenceIssueNumber = parseInt(issueSelect.value);
            updateSelectedIssueDate();
        }

        function updateSelectedIssueDate() {
            const dateSpan = document.getElementById('selectedIssueDate');
            if (issueDateMapping[currentReferenceIssueNumber]) {
                dateSpan.textContent = `(${issueDateMapping[currentReferenceIssueNumber]})`;
            } else {
                dateSpan.textContent = '';
            }
        }

        function renderIssueNumberOptions() {
            const issueSelect = document.getElementById('referenceIssueNumber');
            issueSelect.innerHTML = '';
            
            // å·æ•°ã§ã‚½ãƒ¼ãƒˆ
            const issueNumbers = Object.keys(issueDateMapping).map(Number).sort((a, b) => a - b);
            
            issueNumbers.forEach(issueNum => {
                const option = document.createElement('option');
                option.value = issueNum;
                option.textContent = `${issueNum}å·`;
                if (issueNum === currentReferenceIssueNumber) {
                    option.selected = true;
                }
                issueSelect.appendChild(option);
            });
            
            updateSelectedIssueDate();
        }

        function updateQuerySelection(index, isSelected) {
            querySelections[index] = isSelected;
            updateSelectCount();
            updateQueryItemVisual(index, isSelected);
        }

        function updateSelectCount() {
            const selectedCount = Object.values(querySelections).filter(Boolean).length;
            const totalCount = currentQueries.length;
            document.getElementById('selectCount').textContent = `${selectedCount}/${totalCount} ä½œå“é¸æŠä¸­`;
        }

        function updateQueryItemVisual(index, isSelected) {
            const queryItem = document.querySelector(`[data-query-index="${index}"]`);
            if (queryItem) {
                if (isSelected) {
                    queryItem.classList.remove('disabled');
                } else {
                    queryItem.classList.add('disabled');
                }
            }
        }

        function selectAllQueries() {
            currentQueries.forEach((_, index) => {
                querySelections[index] = true;
                const checkbox = document.querySelector(`input[data-checkbox-index="${index}"]`);
                if (checkbox) checkbox.checked = true;
                updateQueryItemVisual(index, true);
            });
            updateSelectCount();
        }

        function deselectAllQueries() {
            currentQueries.forEach((_, index) => {
                querySelections[index] = false;
                const checkbox = document.querySelector(`input[data-checkbox-index="${index}"]`);
                if (checkbox) checkbox.checked = false;
                updateQueryItemVisual(index, false);
            });
            updateSelectCount();
        }

        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¯ã‚¨ãƒªã‚’å–å¾—
        window.addEventListener('DOMContentLoaded', async () => {
            await loadQueries();
            renderTrendTable();
        });

        async function loadQueries() {
            try {
                const response = await fetch('/api/get_queries');
                const data = await response.json();
                currentQueries = data.queries;
                currentReferenceIssueNumber = data.reference_issue_number;
                issueDateMapping = data.issue_date_mapping;
                
                // å…ƒã®ã‚¯ã‚¨ãƒªã‚’ãƒªã‚¹ãƒˆã¨ã—ã¦ä¿å­˜ï¼ˆã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰å—ã‘å–ã£ãŸãƒªã‚¹ãƒˆã‚’ä½¿ç”¨ï¼‰
                originalQueries = {};
                currentQueries.forEach(query => {
                    // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰query_listãŒæä¾›ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
                    if (query.query_list && Array.isArray(query.query_list)) {
                        originalQueries[query.name] = query.query_list;
                    } else {
                        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚¯ã‚¨ãƒªæ–‡å­—åˆ—ã‚’ãƒ‘ãƒ¼ã‚¹
                        originalQueries[query.name] = parseQueryToList(query.query);
                    }
                });
                
                // é¸æŠçŠ¶æ…‹ã‚’åˆæœŸåŒ–ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§å…¨é¸æŠï¼‰
                querySelections = {};
                currentQueries.forEach((_, index) => {
                    querySelections[index] = true;
                });
                
                // å·æ•°é¸æŠè‚¢ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                renderIssueNumberOptions();
                
                renderQueryEditor();
            } catch (error) {
                console.error('ã‚¯ã‚¨ãƒªã®å–å¾—ã«å¤±æ•—:', error);
            }
        }

        function renderQueryEditor() {
            const queryList = document.getElementById('queryList');
            queryList.innerHTML = '';

            // ãƒˆãƒ¬ãƒ³ãƒ‰ãƒãƒƒãƒ—ã‚’å–å¾—
            const trendMap = getTrendWordsForQuery();

            currentQueries.forEach((query, index) => {
                const item = document.createElement('div');
                item.className = 'query-item';
                item.setAttribute('data-query-index', index);
                const imageUrl = getImageUrl(query.name);
                const isSelected = querySelections[index] !== false; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§é¸æŠ
                
                // ã“ã®ä½œå“ã«é–¢é€£ã™ã‚‹ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰ã‚’å–å¾—
                const trends = trendMap[query.name] || [];
                const hasTrends = trends.length > 0;
                
                // å…ƒã®ã‚¯ã‚¨ãƒªãƒªã‚¹ãƒˆã‚’å–å¾—
                const originalQueryElements = originalQueries[query.name] || [query.query];
                
                // ãƒˆãƒ¬ãƒ³ãƒ‰ã‹ã‚‰å…ƒã®ã‚¯ã‚¨ãƒªã«å«ã¾ã‚Œã¦ã„ãªã„ã‚‚ã®ã ã‘ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆã‚¯ã‚¨ãƒªè¿½åŠ ç”¨ï¼‰
                const newTrends = trends.filter(trend => !originalQueryElements.includes(trend));
                
                // çµ„ã¿åˆã‚ã›ãŸã‚¯ã‚¨ãƒªã‚’ç”Ÿæˆï¼ˆå…ƒã®ã‚¯ã‚¨ãƒªãƒªã‚¹ãƒˆ + é‡è¤‡ã—ã¦ã„ãªã„æ–°ã—ã„ãƒˆãƒ¬ãƒ³ãƒ‰ã®ã¿ï¼‰
                const queryElements = [...originalQueryElements];
                if (newTrends.length > 0) {
                    queryElements.push(...newTrends);
                }
                const combinedQuery = buildQueryFromList(queryElements);
                
                // ãƒˆãƒ¬ãƒ³ãƒ‰æƒ…å ±è¡¨ç¤ºç”¨ã®HTML
                let trendInfoHTML = '';
                if (hasTrends) {
                    trendInfoHTML = `
                        <div class="query-info-section">
                            <div class="query-info-row">
                                <span class="query-info-label">å…ƒã®ã‚¯ã‚¨ãƒª:</span>
                                <span class="query-info-value">${query.query}</span>
                            </div>
                            <div class="query-info-row">
                                <span class="query-info-label">ãƒˆãƒ¬ãƒ³ãƒ‰:</span>
                                <span class="query-info-value">${trends.join(', ')}</span>
                            </div>
                            <div class="query-info-row">
                                <span class="query-info-label">å®Ÿè¡Œã‚¯ã‚¨ãƒª:</span>
                                <span class="query-info-value combined">${combinedQuery}</span>
                            </div>
                        </div>
                    `;
                } else {
                    trendInfoHTML = `
                        <div class="query-info-section">
                            <div class="query-info-row">
                                <span class="query-info-label">ãƒˆãƒ¬ãƒ³ãƒ‰:</span>
                                <span class="query-info-value no-trend">ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰ãªã—</span>
                            </div>
                        </div>
                    `;
                }
                
                item.innerHTML = `
                    <input type="checkbox" class="query-checkbox" data-checkbox-index="${index}" 
                           ${isSelected ? 'checked' : ''} 
                           onchange="updateQuerySelection(${index}, this.checked)">
                    <img src="${imageUrl}" alt="${query.name}" class="query-item-image" onerror="this.style.display='none'">
                    <div class="query-item-content">
                        <div class="query-item-header">
                            <span class="query-item-name">${query.name}</span>
                        </div>
                        <input type="text" value="${query.query}" data-index="${index}" onchange="updateQuery(${index}, this.value)">
                        ${trendInfoHTML}
                    </div>
                `;
                if (!isSelected) {
                    item.classList.add('disabled');
                }
                queryList.appendChild(item);
            });
            updateSelectCount();
        }

        function updateQuery(index, newValue) {
            currentQueries[index].query = newValue;
            // å…ƒã®ã‚¯ã‚¨ãƒªãƒªã‚¹ãƒˆã‚‚æ›´æ–°
            originalQueries[currentQueries[index].name] = parseQueryToList(newValue);
            // ã‚¯ã‚¨ãƒªã‚¨ãƒ‡ã‚£ã‚¿ã‚’å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
            renderQueryEditor();
        }

        async function resetQueries() {
            await loadQueries();
            alert('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¯ã‚¨ãƒªã«æˆ»ã—ã¾ã—ãŸã€‚');
        }

        async function startAnalysis() {
            const startBtn = document.getElementById('startBtn');
            const progressContainer = document.getElementById('progressContainer');
            const resultsContainer = document.getElementById('resultsContainer');
            const summaryTable = document.getElementById('summaryTable');
            const saveBtn = document.getElementById('saveBtn');

            startBtn.disabled = true;
            progressContainer.style.display = 'block';
            resultsContainer.style.display = 'none';
            resultsContainer.innerHTML = '';
            summaryTable.style.display = 'none';
            saveBtn.style.display = 'none';

            try {
                // é¸æŠã•ã‚ŒãŸä½œå“ã®ã¿ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                const selectedQueries = currentQueries.filter((_, index) => querySelections[index]);
                
                if (selectedQueries.length === 0) {
                    alert('è§£æã™ã‚‹ä½œå“ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                    startBtn.disabled = false;
                    progressContainer.style.display = 'none';
                    return;
                }
                
                // ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰ã‚’å„ä½œå“ã®ã‚¯ã‚¨ãƒªã«è¿½åŠ 
                const trendMap = getTrendWordsForQuery();
                const queriesWithTrends = selectedQueries.map(query => {
                    const workName = query.name;
                    const trends = trendMap[workName] || [];
                    
                    // å…ƒã®ã‚¯ã‚¨ãƒªãƒªã‚¹ãƒˆã‚’å–å¾—
                    const originalQueryElements = originalQueries[workName] || [query.query];
                    
                    // ãƒˆãƒ¬ãƒ³ãƒ‰ã‹ã‚‰å…ƒã®ã‚¯ã‚¨ãƒªã«å«ã¾ã‚Œã¦ã„ãªã„ã‚‚ã®ã ã‘ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                    const newTrends = trends.filter(trend => !originalQueryElements.includes(trend));
                    
                    // å…ƒã®ã‚¯ã‚¨ãƒªãƒªã‚¹ãƒˆã«æ–°ã—ã„ãƒˆãƒ¬ãƒ³ãƒ‰ã®ã¿ã‚’è¿½åŠ 
                    const queryElements = [...originalQueryElements];
                    if (newTrends.length > 0) {
                        queryElements.push(...newTrends);
                    }
                    const modifiedQuery = buildQueryFromList(queryElements);
                    
                    return {
                        name: query.name,
                        query: modifiedQuery
                    };
                });
                
                // å€‹ã€…ã®ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰ã‚‚è§£æå¯¾è±¡ã¨ã—ã¦è¿½åŠ 
                const trendQueries = trendWords.map(trend => ({
                    name: `[ãƒˆãƒ¬ãƒ³ãƒ‰] ${trend.word}`,
                    query: trend.word,
                    isTrend: true  // ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
                }));
                
                // ä½œå“ã®ã‚¯ã‚¨ãƒªã¨ãƒˆãƒ¬ãƒ³ãƒ‰ã®ã‚¯ã‚¨ãƒªã‚’çµåˆ
                const allQueries = [...queriesWithTrends, ...trendQueries];
                
                const response = await fetch('/api/start_analysis', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        queries: allQueries,
                        reference_issue_number: currentReferenceIssueNumber,
                        trend_words: trendWords,
                        original_queries: originalQueries
                    })
                });

                if (!response.ok) {
                    throw new Error('è§£æã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }

                // é€²æ—ã®ç›£è¦–ã‚’é–‹å§‹
                progressInterval = setInterval(checkProgress, 1000);

            } catch (error) {
                alert('ã‚¨ãƒ©ãƒ¼: ' + error.message);
                startBtn.disabled = false;
                progressContainer.style.display = 'none';
            }
        }

        async function checkProgress() {
            try {
                const response = await fetch('/api/progress');
                const data = await response.json();

                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');

                if (data.total > 0) {
                    const percentage = Math.round((data.current / data.total) * 100);
                    progressFill.style.width = percentage + '%';
                    progressFill.textContent = percentage + '%';
                    progressText.textContent = `${data.message} (${data.current}/${data.total})`;
                } else {
                    progressText.textContent = data.message;
                }

                if (data.status === 'completed') {
                    clearInterval(progressInterval);
                    progressInterval = null;
                    await loadResults();
                } else if (data.status === 'error') {
                    clearInterval(progressInterval);
                    progressInterval = null;
                    alert('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + data.message);
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('progressContainer').style.display = 'none';
                }

            } catch (error) {
                console.error('é€²æ—ã®å–å¾—ã«å¤±æ•—:', error);
            }
        }

        async function loadResults() {
            try {
                const response = await fetch('/api/results');
                const data = await response.json();

                const resultsContainer = document.getElementById('resultsContainer');
                const summaryTable = document.getElementById('summaryTable');
                const summaryTableContent = document.getElementById('summaryTableContent');
                const saveBtn = document.getElementById('saveBtn');
                const reportBtn = document.getElementById('reportBtn');

                resultsContainer.innerHTML = '';
                currentResults = data.results; // çµæœã‚’ä¿å­˜
                
                // ãƒˆãƒ¬ãƒ³ãƒ‰ã§ãªã„çµæœã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                const workResults = data.results.filter(r => !r.isTrend);
                
                // ä½œå“åã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼ˆãƒˆãƒ¬ãƒ³ãƒ‰ã‚ã‚Šã¨ãƒˆãƒ¬ãƒ³ãƒ‰ãªã—ã‚’ã¾ã¨ã‚ã‚‹ï¼‰
                const groupedResults = {};
                workResults.forEach(result => {
                    const workName = result['ä½œå“å'];
                    if (!groupedResults[workName]) {
                        groupedResults[workName] = {
                            base: null,      // ãƒˆãƒ¬ãƒ³ãƒ‰ãªã—
                            withTrend: null  // ãƒˆãƒ¬ãƒ³ãƒ‰ã‚ã‚Š
                        };
                    }
                    if (result.withTrendWord) {
                        groupedResults[workName].withTrend = result;
                    } else {
                        groupedResults[workName].base = result;
                    }
                });
                
                // ã‚µãƒãƒªãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½œæˆ
                let tableHTML = '<thead><tr><th>ä½œå“å</th><th>å‚ç…§</th><th>1æ™‚é–“é›†è¨ˆ</th><th>å…¨ä½“é›†è¨ˆ</th><th>çµ‚äº†æ™‚åˆ»</th></tr></thead><tbody>';
                
                Object.keys(groupedResults).forEach(workName => {
                    const group = groupedResults[workName];
                    const baseResult = group.base;
                    const trendResult = group.withTrend;
                    
                    if (!baseResult && !trendResult) return;
                    
                    const mainResult = baseResult || trendResult;
                    const imageUrl = getImageUrl(workName);
                    const hasTrend = trendResult !== null;
                    const trendBadge = hasTrend 
                        ? `<span style="background: #667eea; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; margin-left: 5px;">+${trendResult.trendWords.join('+')}</span>` 
                        : '';
                    
                    // ãƒˆãƒ¬ãƒ³ãƒ‰ã‚ã‚Šã®å€¤ã‚’å„ªå…ˆã€ãªã‘ã‚Œã°ãƒˆãƒ¬ãƒ³ãƒ‰ãªã—ã®å€¤ã‚’ä½¿ç”¨ï¼ˆåˆè¨ˆå€¤ï¼‰
                    const oneHourTotal = trendResult ? 
                        (trendResult['1æ™‚é–“é›†è¨ˆ'] !== null ? Math.round(trendResult['1æ™‚é–“é›†è¨ˆ']) : 'N/A') :
                        (baseResult && baseResult['1æ™‚é–“é›†è¨ˆ'] !== null ? Math.round(baseResult['1æ™‚é–“é›†è¨ˆ']) : 'N/A');
                    
                    const totalTotal = trendResult ? 
                        (trendResult['å…¨ä½“é›†è¨ˆ'] !== null ? Math.round(trendResult['å…¨ä½“é›†è¨ˆ']) : 'N/A') :
                        (baseResult && baseResult['å…¨ä½“é›†è¨ˆ'] !== null ? Math.round(baseResult['å…¨ä½“é›†è¨ˆ']) : 'N/A');
                    
                    tableHTML += `
                        <tr>
                            <td>
                                <div class="summary-work-cell">
                                    <img src="${imageUrl}" alt="${workName}" class="summary-work-image" onerror="this.style.display='none'">
                                    <strong>${workName}</strong>${trendBadge}
                                </div>
                            </td>
                            <td>${mainResult['å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ'] !== null ? mainResult['å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ'] : 'N/A'}</td>
                            <td>${oneHourTotal}</td>
                            <td>${totalTotal}</td>
                            <td>${mainResult['å…¨ä½“é›†è¨ˆçµ‚äº†æ™‚åˆ»']}</td>
                        </tr>
                    `;
                });
                
                // ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã•ã‚ŒãŸçµæœã§ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆ
                Object.keys(groupedResults).forEach((workName, groupIndex) => {
                    const group = groupedResults[workName];
                    const baseResult = group.base;
                    const trendResult = group.withTrend;
                    
                    if (!baseResult && !trendResult) return;
                    
                    const mainResult = baseResult || trendResult;
                    if (!mainResult.chart_data) return;
                    
                    const card = document.createElement('div');
                    card.className = 'result-card';
                    const chartId = `chart-group-${groupIndex}`;
                    const imageUrl = getImageUrl(workName);
                    const hasTrend = trendResult !== null;
                    const trendBadge = hasTrend
                        ? `<span style="background: #667eea; color: white; padding: 3px 8px; border-radius: 6px; font-size: 0.85em; margin-left: 8px;">+${trendResult.trendWords.join('+')}</span>`
                        : '';
                    
                    // çµ±è¨ˆæƒ…å ±ã®è¡¨ç¤º
                    let statsHTML = '';
                    if (baseResult && trendResult) {
                        // ä¸¡æ–¹ã‚ã‚‹å ´åˆ
                        statsHTML = `
                            <div class="result-stats">
                                <div class="stat-item reference">
                                    <div class="stat-label">å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ</div>
                                    <div class="stat-value">${mainResult['å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ'] !== null ? mainResult['å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ'] : 'N/A'}</div>
                                </div>
                                <div class="stat-item one-hour">
                                    <div class="stat-label">1æ™‚é–“é›†è¨ˆ</div>
                                    <div class="stat-value">
                                        å…ƒ: ${baseResult['1æ™‚é–“é›†è¨ˆ'] !== null ? Math.round(baseResult['1æ™‚é–“é›†è¨ˆ']) : 'N/A'}<br/>
                                        <span style="color: #667eea;">+ãƒˆãƒ¬ãƒ³ãƒ‰: ${trendResult['1æ™‚é–“é›†è¨ˆ'] !== null ? Math.round(trendResult['1æ™‚é–“é›†è¨ˆ']) : 'N/A'}</span>
                                    </div>
                                </div>
                                <div class="stat-item total">
                                    <div class="stat-label">å…¨ä½“é›†è¨ˆ</div>
                                    <div class="stat-value">
                                        å…ƒ: ${baseResult['å…¨ä½“é›†è¨ˆ'] !== null ? Math.round(baseResult['å…¨ä½“é›†è¨ˆ']) : 'N/A'}<br/>
                                        <span style="color: #667eea;">+ãƒˆãƒ¬ãƒ³ãƒ‰: ${trendResult['å…¨ä½“é›†è¨ˆ'] !== null ? Math.round(trendResult['å…¨ä½“é›†è¨ˆ']) : 'N/A'}</span>
                                    </div>
                                    <div class="stat-time">çµ‚äº†: ${mainResult['å…¨ä½“é›†è¨ˆçµ‚äº†æ™‚åˆ»'] ? new Date('1970-01-01 ' + mainResult['å…¨ä½“é›†è¨ˆçµ‚äº†æ™‚åˆ»'].split(' ')[1]).toLocaleTimeString('ja-JP', {hour: '2-digit', minute: '2-digit'}) : 'N/A'}</div>
                                </div>
                            </div>
                        `;
                    } else {
                        // ã©ã¡ã‚‰ã‹ç‰‡æ–¹ã®ã¿
                        statsHTML = `
                            <div class="result-stats">
                                <div class="stat-item reference">
                                    <div class="stat-label">å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ</div>
                                    <div class="stat-value">${mainResult['å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ'] !== null ? mainResult['å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ'] : 'N/A'}</div>
                                </div>
                                <div class="stat-item one-hour">
                                    <div class="stat-label">1æ™‚é–“é›†è¨ˆ</div>
                                    <div class="stat-value">${mainResult['1æ™‚é–“é›†è¨ˆ'] !== null ? Math.round(mainResult['1æ™‚é–“é›†è¨ˆ']) : 'N/A'}</div>
                                </div>
                                <div class="stat-item total">
                                    <div class="stat-label">å…¨ä½“é›†è¨ˆ</div>
                                    <div class="stat-value">${mainResult['å…¨ä½“é›†è¨ˆ'] !== null ? Math.round(mainResult['å…¨ä½“é›†è¨ˆ']) : 'N/A'}</div>
                                    <div class="stat-time">çµ‚äº†: ${mainResult['å…¨ä½“é›†è¨ˆçµ‚äº†æ™‚åˆ»'] ? new Date('1970-01-01 ' + mainResult['å…¨ä½“é›†è¨ˆçµ‚äº†æ™‚åˆ»'].split(' ')[1]).toLocaleTimeString('ja-JP', {hour: '2-digit', minute: '2-digit'}) : 'N/A'}</div>
                                </div>
                            </div>
                        `;
                    }
                    
                    card.innerHTML = `
                        <div class="result-header">
                            <div class="result-title-container">
                                <img src="${imageUrl}" alt="${workName}" class="result-title-image" onerror="this.style.display='none'">
                                <div class="result-title">${workName}${trendBadge}</div>
                            </div>
                        </div>
                        ${statsHTML}
                        <div class="chart-container">
                            <canvas id="${chartId}"></canvas>
                        </div>
                    `;
                    resultsContainer.appendChild(card);
                    
                    // Chart.jsã§ã‚°ãƒ©ãƒ•ã‚’æç”»ï¼ˆçµ±åˆç‰ˆï¼‰
                    createCombinedChart(chartId, baseResult, trendResult);
                });
                
                // ãƒˆãƒ¬ãƒ³ãƒ‰å°‚ç”¨ã®çµæœã‚‚è¡¨ç¤º
                const trendOnlyResults = data.results.filter(r => r.isTrend);
                trendOnlyResults.forEach((result, trendIndex) => {
                    if (!result.chart_data) return;
                    
                    const card = document.createElement('div');
                    card.className = 'result-card';
                    const chartId = `chart-trend-${trendIndex}`;
                    
                    card.innerHTML = `
                        <div class="result-header">
                            <div class="result-title-container">
                                <div class="result-title" style="color: #667eea;">ğŸ”¥ ${result['ä½œå“å']}</div>
                            </div>
                        </div>
                        <div class="result-stats">
                            <div class="stat-item reference">
                                <div class="stat-label">å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ</div>
                                <div class="stat-value">${result['å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ'] !== null ? result['å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ'] : 'N/A'}</div>
                            </div>
                            <div class="stat-item one-hour">
                                <div class="stat-label">1æ™‚é–“é›†è¨ˆ</div>
                                <div class="stat-value">${result['1æ™‚é–“é›†è¨ˆ'] !== null ? Math.round(result['1æ™‚é–“é›†è¨ˆ']) : 'N/A'}</div>
                            </div>
                            <div class="stat-item total">
                                <div class="stat-label">å…¨ä½“é›†è¨ˆ</div>
                                <div class="stat-value">${result['å…¨ä½“é›†è¨ˆ'] !== null ? Math.round(result['å…¨ä½“é›†è¨ˆ']) : 'N/A'}</div>
                                <div class="stat-time">çµ‚äº†: ${result['å…¨ä½“é›†è¨ˆçµ‚äº†æ™‚åˆ»'] ? new Date('1970-01-01 ' + result['å…¨ä½“é›†è¨ˆçµ‚äº†æ™‚åˆ»'].split(' ')[1]).toLocaleTimeString('ja-JP', {hour: '2-digit', minute: '2-digit'}) : 'N/A'}</div>
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="${chartId}"></canvas>
                        </div>
                    `;
                    resultsContainer.appendChild(card);
                    
                    // é€šå¸¸ã®ã‚°ãƒ©ãƒ•ã‚’æç”»
                    createChart(chartId, result);
                });

                tableHTML += '</tbody>';
                summaryTableContent.innerHTML = tableHTML;

                // ãƒ¬ãƒãƒ¼ãƒˆã‚’è‡ªå‹•è¡¨ç¤º
                document.getElementById('reportContainer').style.display = 'block';
                renderRanking('total');
                
                summaryTable.style.display = 'block';
                resultsContainer.style.display = 'block';
                saveBtn.style.display = 'inline-block';
                document.getElementById('progressContainer').style.display = 'none';
                document.getElementById('startBtn').disabled = false;

                // ãƒ¬ãƒãƒ¼ãƒˆã¾ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                document.getElementById('reportContainer').scrollIntoView({ behavior: 'smooth' });

            } catch (error) {
                alert('çµæœã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                document.getElementById('startBtn').disabled = false;
                document.getElementById('progressContainer').style.display = 'none';
            }
        }

        function createChart(chartId, result) {
            const ctx = document.getElementById(chartId).getContext('2d');
            
            // å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã®ãƒ©ã‚¤ãƒ³ç”¨ãƒ‡ãƒ¼ã‚¿
            const referenceLineData = result.chart_data.map(point => ({
                x: point.x,
                y: result['å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ']
            }));

            // ãƒ‡ãƒ¼ã‚¿ã‚’æ™‚é–“é †ã«ã‚½ãƒ¼ãƒˆ
            const sortedChartData = [...result.chart_data].sort((a, b) => new Date(a.x) - new Date(b.x));
            
            // åŸºæº–æ™‚åˆ»ã®å‰å¾Œ3æ—¥ã®ç¯„å›²ã‚’è¨ˆç®—ï¼ˆåˆè¨ˆ7æ—¥åˆ†ï¼‰
            const referenceDate = new Date(result.reference_base_datetime);
            const threeDaysMs = 3 * 24 * 60 * 60 * 1000; // 3æ—¥ã‚’ãƒŸãƒªç§’ã«å¤‰æ›
            const displayStartTime = new Date(referenceDate.getTime() - threeDaysMs);
            const displayEndTime = new Date(referenceDate.getTime() + threeDaysMs);
            
            // è¡¨ç¤ºç¯„å›²å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            const filteredChartData = sortedChartData.filter(point => {
                const pointDate = new Date(point.x);
                return pointDate >= displayStartTime && pointDate <= displayEndTime;
            });
            
            // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯å…¨ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
            const finalChartData = filteredChartData.length > 0 ? filteredChartData : sortedChartData;
            
            // å®Ÿéš›ã®è¡¨ç¤ºç¯„å›²ã‚’è¨ˆç®—ï¼ˆãƒ‡ãƒ¼ã‚¿ã®æœ€å°ãƒ»æœ€å¤§å€¤ã‚’ä½¿ç”¨ï¼‰
            let actualMinTime, actualMaxTime;
            if (finalChartData.length > 0) {
                actualMinTime = new Date(finalChartData[0].x);
                actualMaxTime = new Date(finalChartData[finalChartData.length - 1].x);
            } else {
                actualMinTime = displayStartTime;
                actualMaxTime = displayEndTime;
            }
            
            // 1æ™‚é–“é›†è¨ˆç¯„å›²ã®ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å–å¾—ï¼ˆ0ã€œ1æ™‚é–“ï¼‰
            const oneHourRangeTimestamps = new Set();
            if (result.one_hour_range_data && result.one_hour_range_data.length > 0) {
                result.one_hour_range_data.forEach(point => {
                    oneHourRangeTimestamps.add(point.x);
                });
            }
            
            // 1æ™‚é–“ä»¥é™ã®é›†è¨ˆç¯„å›²ã®ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å–å¾—ï¼ˆ1æ™‚é–“ã€œå‚ç…§å€¤ã‚’ä¸‹å›ã‚‹ã¾ã§ï¼‰
            const afterOneHourRangeTimestamps = new Set();
            if (result.after_one_hour_range_data && result.after_one_hour_range_data.length > 0) {
                result.after_one_hour_range_data.forEach(point => {
                    afterOneHourRangeTimestamps.add(point.x);
                });
            }
            
            const referenceCount = result['å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ'];
            
            // ç©ã¿ä¸Šã’æ£’ã‚°ãƒ©ãƒ•ç”¨ã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’ä½œæˆ
            // ä¸‹éƒ¨ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ: 0ã€œå‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã¾ã§ï¼ˆã‚°ãƒ¬ãƒ¼ï¼‰
            const lowerSegmentData = finalChartData.map(point => ({
                x: point.x,
                y: Math.min(point.y, referenceCount)
            }));
            
            // ä¸Šéƒ¨ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ: å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚ˆã‚Šä¸Šï¼ˆè‰²åˆ†ã‘ï¼‰
            const upperSegmentData = finalChartData.map(point => ({
                x: point.x,
                y: Math.max(0, point.y - referenceCount)
            }));
            
            // ä¸‹éƒ¨ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®è‰²ï¼ˆé›†è¨ˆå¯¾è±¡å†…å¤–å•ã‚ãšå¸¸ã«ã‚°ãƒ¬ãƒ¼ï¼‰
            const lowerSegmentColors = finalChartData.map(point => {
                return 'rgba(128, 128, 128, 0.5)'; // ã‚°ãƒ¬ãƒ¼ï¼ˆå‚ç…§ã‚«ã‚¦ãƒ³ãƒˆä»¥ä¸‹ï¼‰
            });
            
            const lowerSegmentBorderColors = finalChartData.map(point => {
                return 'rgba(128, 128, 128, 0.8)'; // ã‚°ãƒ¬ãƒ¼ï¼ˆå‚ç…§ã‚«ã‚¦ãƒ³ãƒˆä»¥ä¸‹ï¼‰
            });
            
            // ä¸Šéƒ¨ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®è‰²åˆ†ã‘ï¼ˆé›†è¨ˆå¯¾è±¡å†…ã®ã¿æ°´è‰²/é’è‰²ã€å¯¾è±¡å¤–ã¯ã‚°ãƒ¬ãƒ¼ï¼‰
            const upperSegmentColors = finalChartData.map(point => {
                if (oneHourRangeTimestamps.has(point.x)) {
                    return 'rgba(54, 162, 235, 0.8)'; // æ°´è‰²ï¼ˆ0ã€œ1æ™‚é–“é›†è¨ˆç¯„å›²ï¼‰
                } else if (afterOneHourRangeTimestamps.has(point.x)) {
                    return 'rgba(41, 98, 255, 0.8)'; // é’è‰²ï¼ˆ1æ™‚é–“ä»¥é™ã®é›†è¨ˆç¯„å›²ï¼‰
                } else {
                    return 'rgba(128, 128, 128, 0.5)'; // ã‚°ãƒ¬ãƒ¼ï¼ˆé›†è¨ˆå¯¾è±¡å¤–ï¼‰
                }
            });
            
            const upperSegmentBorderColors = finalChartData.map(point => {
                if (oneHourRangeTimestamps.has(point.x)) {
                    return 'rgba(54, 162, 235, 1)'; // æ°´è‰²ï¼ˆ0ã€œ1æ™‚é–“é›†è¨ˆç¯„å›²ï¼‰
                } else if (afterOneHourRangeTimestamps.has(point.x)) {
                    return 'rgba(41, 98, 255, 1)'; // é’è‰²ï¼ˆ1æ™‚é–“ä»¥é™ã®é›†è¨ˆç¯„å›²ï¼‰
                } else {
                    return 'rgba(128, 128, 128, 0.8)'; // ã‚°ãƒ¬ãƒ¼ï¼ˆé›†è¨ˆå¯¾è±¡å¤–ï¼‰
                }
            });
            
            const datasets = [
                {
                    label: 'å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆä»¥ä¸‹',
                    data: lowerSegmentData,
                    backgroundColor: lowerSegmentColors,
                    borderColor: lowerSegmentBorderColors,
                    borderWidth: 1,
                    maxBarThickness: 20,
                    stack: 'stack1'
                },
                {
                    label: 'å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆè¶…é',
                    data: upperSegmentData,
                    backgroundColor: upperSegmentColors,
                    borderColor: upperSegmentBorderColors,
                    borderWidth: 1,
                    maxBarThickness: 20,
                    stack: 'stack1'
                }
            ];

            new Chart(ctx, {
                type: 'bar',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: true,
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: actualMinTime,
                            max: actualMaxTime,
                            time: {
                                unit: 'hour',
                                parser: false,
                                displayFormats: {
                                    hour: 'MM/dd HH:mm'
                                },
                                tooltipFormat: 'YYYY/MM/DD HH:mm'
                            },
                            adapters: {
                                date: {}
                            },
                            title: {
                                display: true,
                                text: 'æ—¥æ™‚',
                                font: { size: 14 }
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 15
                            },
                            offset: false
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'ãƒã‚¹ãƒˆæ•°',
                                font: { size: 14 }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: false,
                        },
                        legend: {
                            display: false,
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    // ç©ã¿ä¸Šã’ã‚°ãƒ©ãƒ•ã®å ´åˆã€åˆè¨ˆå€¤ã‚’è¡¨ç¤º
                                    const dataIndex = context.dataIndex;
                                    const datasets = context.chart.data.datasets;
                                    let total = 0;
                                    datasets.forEach(dataset => {
                                        total += dataset.data[dataIndex].y;
                                    });
                                    return 'ãƒã‚¹ãƒˆæ•°: ' + total;
                                },
                                afterLabel: function(context) {
                                    // å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’è¡¨ç¤º
                                    const refCount = result['å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ'];
                                    return 'å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ: ' + refCount.toFixed(2);
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                // å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã®æ°´å¹³ç·š
                                referenceCountLine: {
                                    type: 'line',
                                    yMin: referenceCount,
                                    yMax: referenceCount,
                                    borderColor: 'rgb(76, 175, 80)',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        display: true,
                                        content: `å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ: ${referenceCount.toFixed(2)}`,
                                        position: 'end',
                                        backgroundColor: 'rgb(76, 175, 80)',
                                        color: 'white',
                                        font: {
                                            size: 11,
                                            weight: 'bold'
                                        },
                                        padding: 4
                                    }
                                },
                                // åŸºæº–æ™‚åˆ»ã®å‚ç›´ç·š
                                referenceTimeLine: {
                                    type: 'line',
                                    xMin: referenceDate,
                                    xMax: referenceDate,
                                    borderColor: 'rgb(255, 99, 132)',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        display: true,
                                        content: 'åŸºæº–æ™‚åˆ»',
                                        position: 'start',
                                        backgroundColor: 'rgb(255, 99, 132)',
                                        color: 'white',
                                        font: {
                                            size: 11,
                                            weight: 'bold'
                                        },
                                        padding: 4,
                                        yAdjust: -10
                                    }
                                }
                            }
                        }
                    },
                }
            });
        }

        function createCombinedChart(chartId, baseResult, trendResult) {
            const ctx = document.getElementById(chartId).getContext('2d');
            
            // ä½¿ç”¨ã™ã‚‹çµæœãƒ‡ãƒ¼ã‚¿ã‚’æ±ºå®š
            const mainResult = baseResult || trendResult;
            const referenceCount = mainResult['å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ'];
            const referenceDate = new Date(mainResult.reference_base_datetime);
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’æ™‚é–“é †ã«ã‚½ãƒ¼ãƒˆ
            const sortedChartData = [...mainResult.chart_data].sort((a, b) => new Date(a.x) - new Date(b.x));
            
            // åŸºæº–æ™‚åˆ»ã®å‰å¾Œ3æ—¥ã®ç¯„å›²ã‚’è¨ˆç®—
            const threeDaysMs = 3 * 24 * 60 * 60 * 1000;
            const displayStartTime = new Date(referenceDate.getTime() - threeDaysMs);
            const displayEndTime = new Date(referenceDate.getTime() + threeDaysMs);
            
            // è¡¨ç¤ºç¯„å›²å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            const filteredChartData = sortedChartData.filter(point => {
                const pointDate = new Date(point.x);
                return pointDate >= displayStartTime && pointDate <= displayEndTime;
            });
            
            const finalChartData = filteredChartData.length > 0 ? filteredChartData : sortedChartData;
            
            // å®Ÿéš›ã®è¡¨ç¤ºç¯„å›²ã‚’è¨ˆç®—
            let actualMinTime, actualMaxTime;
            if (finalChartData.length > 0) {
                actualMinTime = new Date(finalChartData[0].x);
                actualMaxTime = new Date(finalChartData[finalChartData.length - 1].x);
            } else {
                actualMinTime = displayStartTime;
                actualMaxTime = displayEndTime;
            }
            
            // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®ãƒãƒƒãƒ—ã‚’ä½œæˆ
            const baseOneHourTimestamps = new Set();
            const baseAfterOneHourTimestamps = new Set();
            const trendOneHourTimestamps = new Set();
            const trendAfterOneHourTimestamps = new Set();
            
            if (baseResult) {
                if (baseResult.one_hour_range_data) {
                    baseResult.one_hour_range_data.forEach(point => baseOneHourTimestamps.add(point.x));
                }
                if (baseResult.after_one_hour_range_data) {
                    baseResult.after_one_hour_range_data.forEach(point => baseAfterOneHourTimestamps.add(point.x));
                }
            }
            
            if (trendResult) {
                if (trendResult.one_hour_range_data) {
                    trendResult.one_hour_range_data.forEach(point => trendOneHourTimestamps.add(point.x));
                }
                if (trendResult.after_one_hour_range_data) {
                    trendResult.after_one_hour_range_data.forEach(point => trendAfterOneHourTimestamps.add(point.x));
                }
            }
            
            // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã¨ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒƒãƒ”ãƒ³ã‚°
            const baseDataMap = new Map();
            const trendDataMap = new Map();
            
            if (baseResult && baseResult.chart_data) {
                baseResult.chart_data.forEach(point => {
                    baseDataMap.set(point.x, point.y);
                });
            }
            
            if (trendResult && trendResult.chart_data) {
                trendResult.chart_data.forEach(point => {
                    trendDataMap.set(point.x, point.y);
                });
            }
            
            // ç©ã¿ä¸Šã’ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’ä½œæˆ
            const datasets = [];
            
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼1: å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆä»¥ä¸‹ï¼ˆã‚°ãƒ¬ãƒ¼ï¼‰
            const lowerSegmentData = finalChartData.map(point => ({
                x: point.x,
                y: Math.min(baseDataMap.get(point.x) || 0, referenceCount)
            }));
            
            datasets.push({
                label: 'å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆä»¥ä¸‹',
                data: lowerSegmentData,
                backgroundColor: 'rgba(128, 128, 128, 0.5)',
                borderColor: 'rgba(128, 128, 128, 0.8)',
                borderWidth: 1,
                maxBarThickness: 20,
                stack: 'stack1'
            });
            
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼2: å…ƒã®ã‚¯ã‚¨ãƒªã®å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆè¶…éï¼ˆæ°´è‰²/é’è‰²/ã‚°ãƒ¬ãƒ¼ï¼‰
            const baseUpperSegmentData = finalChartData.map(point => ({
                x: point.x,
                y: Math.max(0, (baseDataMap.get(point.x) || 0) - referenceCount)
            }));
            
            const baseUpperColors = finalChartData.map(point => {
                if (baseOneHourTimestamps.has(point.x)) {
                    return 'rgba(54, 162, 235, 0.8)'; // æ°´è‰²ï¼ˆ0ã€œ1æ™‚é–“ï¼‰
                } else if (baseAfterOneHourTimestamps.has(point.x)) {
                    return 'rgba(41, 98, 255, 0.8)'; // é’è‰²ï¼ˆ1æ™‚é–“ä»¥é™ï¼‰
                } else {
                    return 'rgba(128, 128, 128, 0.5)'; // ã‚°ãƒ¬ãƒ¼ï¼ˆå¯¾è±¡å¤–ï¼‰
                }
            });
            
            const baseUpperBorderColors = finalChartData.map(point => {
                if (baseOneHourTimestamps.has(point.x)) {
                    return 'rgba(54, 162, 235, 1)';
                } else if (baseAfterOneHourTimestamps.has(point.x)) {
                    return 'rgba(41, 98, 255, 1)';
                } else {
                    return 'rgba(128, 128, 128, 0.8)';
                }
            });
            
            datasets.push({
                label: 'å…ƒã®ã‚¯ã‚¨ãƒª',
                data: baseUpperSegmentData,
                backgroundColor: baseUpperColors,
                borderColor: baseUpperBorderColors,
                borderWidth: 1,
                maxBarThickness: 20,
                stack: 'stack1'
            });
            
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼3: ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰ä»˜ãã®å¢—åŠ åˆ†ï¼ˆç´«ç³»ã®è‰²ï¼‰
            if (trendResult) {
                const trendDiffData = finalChartData.map(point => {
                    const baseValue = baseDataMap.get(point.x) || 0;
                    const trendValue = trendDataMap.get(point.x) || 0;
                    return {
                        x: point.x,
                        y: Math.max(0, trendValue - baseValue)
                    };
                });
                
                const trendDiffColors = finalChartData.map(point => {
                    if (trendOneHourTimestamps.has(point.x)) {
                        return 'rgba(153, 102, 255, 0.8)'; // ç´«ï¼ˆ0ã€œ1æ™‚é–“ï¼‰
                    } else if (trendAfterOneHourTimestamps.has(point.x)) {
                        return 'rgba(102, 51, 204, 0.8)'; // æ¿ƒã„ç´«ï¼ˆ1æ™‚é–“ä»¥é™ï¼‰
                    } else {
                        return 'rgba(180, 180, 180, 0.5)'; // è–„ã„ã‚°ãƒ¬ãƒ¼ï¼ˆå¯¾è±¡å¤–ï¼‰
                    }
                });
                
                const trendDiffBorderColors = finalChartData.map(point => {
                    if (trendOneHourTimestamps.has(point.x)) {
                        return 'rgba(153, 102, 255, 1)';
                    } else if (trendAfterOneHourTimestamps.has(point.x)) {
                        return 'rgba(102, 51, 204, 1)';
                    } else {
                        return 'rgba(180, 180, 180, 0.8)';
                    }
                });
                
                datasets.push({
                    label: 'ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰åŠ¹æœ',
                    data: trendDiffData,
                    backgroundColor: trendDiffColors,
                    borderColor: trendDiffBorderColors,
                    borderWidth: 1,
                    maxBarThickness: 20,
                    stack: 'stack1'
                });
            }
            
            new Chart(ctx, {
                type: 'bar',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: true,
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: actualMinTime,
                            max: actualMaxTime,
                            time: {
                                unit: 'hour',
                                parser: false,
                                displayFormats: {
                                    hour: 'MM/dd HH:mm'
                                },
                                tooltipFormat: 'YYYY/MM/DD HH:mm'
                            },
                            adapters: {
                                date: {}
                            },
                            title: {
                                display: true,
                                text: 'æ—¥æ™‚',
                                font: { size: 14 }
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 15
                            },
                            offset: false
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'ãƒã‚¹ãƒˆæ•°',
                                font: { size: 14 }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: false,
                        },
                        legend: {
                            display: true,
                            position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    return label + ': ' + Math.round(value);
                                },
                                afterLabel: function(context) {
                                    if (context.datasetIndex === 0) {
                                        return 'å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ: ' + referenceCount.toFixed(2);
                                    }
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                referenceCountLine: {
                                    type: 'line',
                                    yMin: referenceCount,
                                    yMax: referenceCount,
                                    borderColor: 'rgb(76, 175, 80)',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        display: true,
                                        content: `å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ: ${referenceCount.toFixed(2)}`,
                                        position: 'end',
                                        backgroundColor: 'rgb(76, 175, 80)',
                                        color: 'white',
                                        font: {
                                            size: 11,
                                            weight: 'bold'
                                        },
                                        padding: 4
                                    }
                                },
                                referenceTimeLine: {
                                    type: 'line',
                                    xMin: referenceDate,
                                    xMax: referenceDate,
                                    borderColor: 'rgb(255, 99, 132)',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        display: true,
                                        content: 'åŸºæº–æ™‚åˆ»',
                                        position: 'start',
                                        backgroundColor: 'rgb(255, 99, 132)',
                                        color: 'white',
                                        font: {
                                            size: 11,
                                            weight: 'bold'
                                        },
                                        padding: 4,
                                        yAdjust: -10
                                    }
                                }
                            }
                        }
                    },
                }
            });
        }
        
        function removeTrend(index) {
            if (trendWords.length > 1) {
                if (confirm('ã“ã®ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹?')) {
                    trendWords.splice(index, 1);
                    renderTrendTable();
                    updateQueryInfoSections(); // ã‚¯ã‚¨ãƒªæƒ…å ±ã®ã¿æ›´æ–°
                }
            }
        }
        
        function updateTrend(index, field, value) {
            trendWords[index][field] = value;
            
            // å…¨ã¦ã®å…¥åŠ›æ¬„ãŒåŸ‹ã¾ã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            checkAndAddNewRow();
        }
        
        function updateTrendAndRefresh(index, field, value) {
            // é¸æŠå®Œäº†æ™‚ï¼ˆselectã®onchangeï¼‰ã‚„ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚¢ã‚¦ãƒˆæ™‚ã«å‘¼ã°ã‚Œã‚‹
            trendWords[index][field] = value;
            checkAndAddNewRow();
            
            // è©²å½“ã™ã‚‹ä½œå“ã®ãƒˆãƒ¬ãƒ³ãƒ‰æƒ…å ±ã®ã¿ã‚’æ›´æ–°
            updateQueryInfoSections();
        }
        
        function checkAndAddNewRow() {
            // å…¨ã¦ã®è¡ŒãŒåŸ‹ã¾ã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const allFilled = trendWords.every(trend => 
                trend.word && trend.word.trim() !== '' &&
                trend.workName && trend.workName.trim() !== '' &&
                trend.rank && trend.rank.trim() !== ''
            );
            
            // å…¨ã¦åŸ‹ã¾ã£ã¦ã„ã¦ã€ã‹ã¤æœ€å¾Œã®è¡Œã‚‚åŸ‹ã¾ã£ã¦ã„ã‚‹å ´åˆã¯æ–°ã—ã„è¡Œã‚’è¿½åŠ 
            if (allFilled && trendWords.length > 0) {
                trendWords.push({ word: '', workName: '', rank: '' });
                renderTrendTable();
            }
        }
        
        function updateQueryInfoSections() {
            // ãƒˆãƒ¬ãƒ³ãƒ‰ãƒãƒƒãƒ—ã‚’å–å¾—
            const trendMap = getTrendWordsForQuery();
            
            // å„ã‚¯ã‚¨ãƒªã‚¢ã‚¤ãƒ†ãƒ ã®ãƒˆãƒ¬ãƒ³ãƒ‰æƒ…å ±ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã¿ã‚’æ›´æ–°
            currentQueries.forEach((query, index) => {
                const queryItem = document.querySelector(`[data-query-index="${index}"]`);
                if (!queryItem) return;
                
                const infoSection = queryItem.querySelector('.query-info-section');
                if (!infoSection) return;
                
                // ã“ã®ä½œå“ã«é–¢é€£ã™ã‚‹ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰ã‚’å–å¾—
                const trends = trendMap[query.name] || [];
                const hasTrends = trends.length > 0;
                
                // å…ƒã®ã‚¯ã‚¨ãƒªãƒªã‚¹ãƒˆã‚’å–å¾—
                const originalQueryElements = originalQueries[query.name] || [query.query];
                
                // ãƒˆãƒ¬ãƒ³ãƒ‰ã‹ã‚‰å…ƒã®ã‚¯ã‚¨ãƒªã«å«ã¾ã‚Œã¦ã„ãªã„ã‚‚ã®ã ã‘ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆã‚¯ã‚¨ãƒªè¿½åŠ ç”¨ï¼‰
                const newTrends = trends.filter(trend => !originalQueryElements.includes(trend));
                
                // çµ„ã¿åˆã‚ã›ãŸã‚¯ã‚¨ãƒªã‚’ç”Ÿæˆï¼ˆå…ƒã®ã‚¯ã‚¨ãƒªãƒªã‚¹ãƒˆ + é‡è¤‡ã—ã¦ã„ãªã„æ–°ã—ã„ãƒˆãƒ¬ãƒ³ãƒ‰ã®ã¿ï¼‰
                const queryElements = [...originalQueryElements];
                if (newTrends.length > 0) {
                    queryElements.push(...newTrends);
                }
                const combinedQuery = buildQueryFromList(queryElements);
                
                // ãƒˆãƒ¬ãƒ³ãƒ‰æƒ…å ±è¡¨ç¤ºç”¨ã®HTML
                if (hasTrends) {
                    infoSection.innerHTML = `
                        <div class="query-info-row">
                            <span class="query-info-label">å…ƒã®ã‚¯ã‚¨ãƒª:</span>
                            <span class="query-info-value">${query.query}</span>
                        </div>
                        <div class="query-info-row">
                            <span class="query-info-label">ãƒˆãƒ¬ãƒ³ãƒ‰:</span>
                            <span class="query-info-value">${trends.join(', ')}</span>
                        </div>
                        <div class="query-info-row">
                            <span class="query-info-label">å®Ÿè¡Œã‚¯ã‚¨ãƒª:</span>
                            <span class="query-info-value combined">${combinedQuery}</span>
                        </div>
                    `;
                } else {
                    infoSection.innerHTML = `
                        <div class="query-info-row">
                            <span class="query-info-label">ãƒˆãƒ¬ãƒ³ãƒ‰:</span>
                            <span class="query-info-value no-trend">ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰ãªã—</span>
                        </div>
                    `;
                }
            });
        }

        async function saveToCSV() {
            const saveBtn = document.getElementById('saveBtn');
            const originalText = saveBtn.innerHTML;
            
            try {
                saveBtn.disabled = true;
                saveBtn.innerHTML = 'ğŸ’¾ ä¿å­˜ä¸­...';
                
                const response = await fetch('/api/save_to_csv', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        issue_number: currentReferenceIssueNumber,
                        trend_words: trendWords  // ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰æƒ…å ±ã‚’é€ä¿¡
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    alert(`âœ… ${data.message}`);
                    saveBtn.innerHTML = 'âœ“ ä¿å­˜å®Œäº†';
                    setTimeout(() => {
                        saveBtn.innerHTML = originalText;
                    }, 2000);
                } else {
                    alert(`âŒ ã‚¨ãƒ©ãƒ¼: ${data.error}`);
                    saveBtn.innerHTML = originalText;
                }
            } catch (error) {
                alert(`âŒ ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
                saveBtn.innerHTML = originalText;
            } finally {
                saveBtn.disabled = false;
            }
        }

        // ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰ç®¡ç†æ©Ÿèƒ½
        function renderTrendTable() {
            const tbody = document.getElementById('trendTableBody');
            tbody.innerHTML = '';
            
            // æœ€ä½1è¡Œã¯è¡¨ç¤ºã™ã‚‹
            if (trendWords.length === 0) {
                trendWords.push({ word: '', workName: '', rank: '' });
            }
            
            trendWords.forEach((trend, index) => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid #e0e0e0';
                
                // ä½œå“åãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã®é¸æŠè‚¢ã‚’ç”Ÿæˆ
                let workSelectOptions = '<option value="">-- ä½œå“ã‚’é¸æŠ --</option>';
                currentQueries.forEach(query => {
                    const selected = trend.workName === query.name ? 'selected' : '';
                    workSelectOptions += `<option value="${query.name}" ${selected}>${query.name}</option>`;
                });
                
                row.innerHTML = `
                    <td style="padding: 10px;">
                        <input type="text" value="${trend.word}" 
                               oninput="updateTrend(${index}, 'word', this.value)"
                               onblur="updateTrendAndRefresh(${index}, 'word', this.value)"
                               style="width: 100%; padding: 6px; border: 1px solid #e0e0e0; border-radius: 4px;">
                    </td>
                    <td style="padding: 10px;">
                        <select onchange="updateTrendAndRefresh(${index}, 'workName', this.value)"
                                style="width: 100%; padding: 6px; border: 1px solid #e0e0e0; border-radius: 4px;">
                            ${workSelectOptions}
                        </select>
                    </td>
                    <td style="padding: 10px;">
                        <input type="text" value="${trend.rank}" 
                               oninput="updateTrend(${index}, 'rank', this.value)"
                               onblur="updateTrendAndRefresh(${index}, 'rank', this.value)"
                               style="width: 100%; padding: 6px; border: 1px solid #e0e0e0; border-radius: 4px;">
                    </td>
                    <td style="padding: 10px; text-align: center;">
                        <button class="btn btn-danger btn-small" onclick="removeTrend(${index})" 
                                style="${trendWords.length === 1 ? 'visibility: hidden;' : ''}">
                            å‰Šé™¤
                        </button>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }
        
        // ã‚¯ã‚¨ãƒªè¦ç´ ã®ãƒªã‚¹ãƒˆã‹ã‚‰ã‚¯ã‚¨ãƒªæ–‡å­—åˆ—ã‚’ä½œæˆã™ã‚‹é–¢æ•°
        function buildQueryFromList(queryList) {
            if (!queryList || queryList.length === 0) return '';
            if (queryList.length === 1) return queryList[0];
            return '(' + queryList.join(' ') + ')';
        }
        
        // ã‚¯ã‚¨ãƒªæ–‡å­—åˆ—ã‚’ãƒªã‚¹ãƒˆã«åˆ†è§£ã™ã‚‹é–¢æ•°
        function parseQueryToList(queryString) {
            // æ‹¬å¼§ã‚’å–ã‚Šé™¤ã„ã¦ã‚¹ãƒšãƒ¼ã‚¹ã§åˆ†å‰²
            const cleaned = queryString.replace(/^\(+|\)+$/g, '').trim();
            return cleaned ? [cleaned] : [];
        }
        
        function getTrendWordsForQuery() {
            // å„ä½œå“ã®ã‚¯ã‚¨ãƒªã«è¿½åŠ ã™ã‚‹ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ¯ãƒ¼ãƒ‰ã‚’å–å¾—
            const trendMap = {};
            trendWords.forEach(trend => {
                if (trend.word && trend.workName) {
                    if (!trendMap[trend.workName]) {
                        trendMap[trend.workName] = [];
                    }
                    trendMap[trend.workName].push(trend.word);
                }
            });
            return trendMap;
        }

        function renderRanking(sortBy) {
            if (!currentResults) return;
            
            const rankingGrid = document.getElementById('rankingGrid');
            rankingGrid.innerHTML = '';
            
            const sortKey = 'å…¨ä½“é›†è¨ˆ';
            
            // ãƒˆãƒ¬ãƒ³ãƒ‰ã§ãªã„çµæœã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            const workResults = currentResults.filter(r => !r.isTrend);
            
            // ä½œå“åã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼ˆãƒˆãƒ¬ãƒ³ãƒ‰ã‚ã‚Šã¨ãƒˆãƒ¬ãƒ³ãƒ‰ãªã—ã‚’ã¾ã¨ã‚ã‚‹ï¼‰
            const groupedResults = {};
            workResults.forEach(result => {
                const workName = result['ä½œå“å'];
                if (!groupedResults[workName]) {
                    groupedResults[workName] = {
                        base: null,      // ãƒˆãƒ¬ãƒ³ãƒ‰ãªã—
                        withTrend: null  // ãƒˆãƒ¬ãƒ³ãƒ‰ã‚ã‚Š
                    };
                }
                if (result.withTrendWord) {
                    groupedResults[workName].withTrend = result;
                } else {
                    groupedResults[workName].base = result;
                }
            });
            
            // å„ä½œå“ã®åˆè¨ˆãƒ„ã‚¤ãƒ¼ãƒˆæ•°ã‚’è¨ˆç®—
            const workSummaries = [];
            Object.keys(groupedResults).forEach(workName => {
                const group = groupedResults[workName];
                const baseResult = group.base;
                const trendResult = group.withTrend;
                
                // ãƒˆãƒ¬ãƒ³ãƒ‰ã‚ã‚Šã®å€¤ã‚’å„ªå…ˆã€ãªã‘ã‚Œã°ãƒˆãƒ¬ãƒ³ãƒ‰ãªã—ã®å€¤ã‚’ä½¿ç”¨
                const totalCount = trendResult ? 
                    (trendResult[sortKey] !== null ? trendResult[sortKey] : 0) :
                    (baseResult && baseResult[sortKey] !== null ? baseResult[sortKey] : 0);
                
                const baseCount = baseResult && baseResult[sortKey] !== null ? baseResult[sortKey] : 0;
                const trendOnlyCount = totalCount - baseCount;
                
                workSummaries.push({
                    workName: workName,
                    totalCount: totalCount,
                    baseCount: baseCount,
                    trendOnlyCount: trendOnlyCount,
                    hasTrend: trendResult !== null,
                    trendWords: trendResult ? trendResult.trendWords : []
                });
            });
            
            // åˆè¨ˆãƒ„ã‚¤ãƒ¼ãƒˆæ•°ã§ã‚½ãƒ¼ãƒˆ
            const sortedSummaries = workSummaries
                .filter(s => s.totalCount > 0)
                .sort((a, b) => b.totalCount - a.totalCount)
                .slice(0, 10);
            
            // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚«ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
            sortedSummaries.forEach((summary, index) => {
                const rank = index + 1;
                const card = document.createElement('div');
                card.className = `rank-card rank-${rank}`;
                
                const imageUrl = getImageUrl(summary.workName);
                
                // ãƒˆãƒ¬ãƒ³ãƒ‰æƒ…å ±ã®HTMLç”Ÿæˆ
                let trendsHTML = '';
                if (summary.hasTrend && summary.trendWords.length > 0) {
                    trendsHTML = '<div class="rank-trends"><div class="rank-trends-title">ğŸ”¥ ãƒˆãƒ¬ãƒ³ãƒ‰åŠ¹æœ</div>';
                    trendsHTML += `
                        <div class="rank-trend-item">
                            <span class="rank-trend-word">${summary.trendWords.join(', ')}</span>
                            <span class="rank-trend-count">+${Math.round(summary.trendOnlyCount)}</span>
                        </div>
                    `;
                    trendsHTML += `
                        <div class="rank-trend-item" style="font-size: 0.85em; color: #888;">
                            <span class="rank-trend-word">å…ƒã®ã‚¯ã‚¨ãƒª</span>
                            <span class="rank-trend-count">${Math.round(summary.baseCount)}</span>
                        </div>
                    `;
                    trendsHTML += '</div>';
                }
                
                card.innerHTML = `
                    <div class="rank-number">${rank}</div>
                    <div class="rank-content">
                        <img src="${imageUrl}" alt="${summary.workName}" class="rank-image" onerror="this.style.display='none'">
                        <div>
                            <div class="rank-work-name">${summary.workName}</div>
                        </div>
                    </div>
                    <div class="rank-value">${Math.round(summary.totalCount)}</div>
                    ${trendsHTML}
                `;
                
                rankingGrid.appendChild(card);
            });
        }
    </script>
</body>
</html>
